<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes" name="viewport" />
    <meta content="yes" name="apple-mobile-web-app-capable" />
    <meta content="black" name="apple-mobile-web-app-status-bar-style" />
    <meta content="telephone=no" name="format-detection" />
    <title>Front-end-problem</title>
    <style>
        html, body {
            height: 100%;
        }
        body {
            margin: 0;
            padding: 0;
        }
        @media (orientation: portrait) {  
            #myCanvas{
                margin: 0px auto;
                display: flex;
                border: 1px solid;
                width: 80%;
            }
        }
        @media (orientation: landscape) {
            #myCanvas{
                margin: 0px auto;
                display: flex;
                border: 1px solid;
                width: 70%;
            }
        }
        div {
            text-align:center;
        }
    </style>
</head>
<body onload="init();">
    <canvas id="myCanvas" ></canvas>
    <div id="timer"></div>
    <div id="footer">AlbertShih</div>
</body>
</html>
<script>/*可能碰上問題
    var PIXEL_RATIO = (function () {
        var ctx = document.createElement("canvas").getContext("2d"),
            dpr = window.devicePixelRatio || 1,
            bsr = ctx.webkitBackingStorePixelRatio ||
                  ctx.mozBackingStorePixelRatio ||
                  ctx.msBackingStorePixelRatio ||
                  ctx.oBackingStorePixelRatio ||
                  ctx.backingStorePixelRatio || 1;

        return dpr / bsr;
    })();*/

    // var $ = function (el) {
    //     return document.querySelector(el);
    // };

    // 比例為 4:3 ，橫向居中的方塊
    //canvas.style.width  = '800px';
    //canvas.style.height = '600px';
    var canvas = document.getElementById("myCanvas");
    //手機打直的時候占畫面寬度的 80%，打橫的時候占畫面寬度的 70%在CSS設定
    canvas.width = document.body.clientWidth;   
    canvas.height = canvas.width*0.75;  //維持比例4:3,  
    
    var ctx = canvas.getContext("2d"); // 取得繪圖環境
    var picWidth = canvas.width/8;
    var picHeight = canvas.height/6;
    var diagonal = Math.pow(Math.pow(picWidth, 2) + Math.pow(picHeight, 2), 0.5);
    var itemArray = [];     //放圖片item的陣列
    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var countdownnumber = 120;
    var countdownid, showTimer;
    
    function Item(x, y, img) {          //圖片item的object
        this.x = x;
        this.y = y;
        this.img = img;
    }
    
    var round = function(min, max){     //在max~min中取得亂數
        var choices = max - min + 1;
        return (Math.random() * choices + min) | 0;
    }

    var loadImage = function (index){        //設定並記錄圖片要畫在canvas中的座標位置,如跟其他張圖片重疊必須另取新位置
        var isOk = false;

        while(!isOk){
            var drawX = round(0, canvas.width*(7/8));   //canvas寬度為8倍圖片寬
            var drawY = round(0, canvas.height*(5/6));  //canvas高度為6倍圖片ㄨ
            isOk = true;

            if(itemArray.length > 0){  //判斷不重疊方式：生成之點不能位於已存在之相片左上角為圓心,對角線為直徑所畫之圓內
                for(var i=0; i<itemArray.length; i++) { 
                     if(Math.pow(Math.pow(itemArray[i].x - drawX, 2) + Math.pow(itemArray[i].y - drawY, 2), 0.5) < diagonal){
                        isOk = false;
                        break;
                     }
                     isOk = true;       //如果沒重疊,圖片可以生成在目前取得之座標位置
                }
            }    
            if(isOk){                                      
                var img = new Image();       //new img element,並設定來源
                img.src = "images/" + arr[index] + ".png";         
                itemArray.push(new Item(drawX, drawY, img));     //push入array存放
                /*img.addEventListener("load", function() {
                    //alert("draw"+img.src+" "+drawX +" " +drawY);
                    //readyToDraw(img, drawX, drawY);
                }, false);*/ 
            }
        }  
    }

    var isDragging = false;
    var nowDrag;
    var ani = ["豬","牛","虎","兔","龍","蛇","馬","羊","猴","雞","狗","鼠"];

    var handleImage = function(index){
        ctx.drawImage(itemArray[arr[index]].img, itemArray[arr[index]].x, itemArray[arr[index]].y , picWidth, picHeight);
        console.log(ani[arr[index]]+" x:"+itemArray[arr[index]].x+" y:"+itemArray[arr[index]].y);
        // ctx.rect(itemArray[arr[index]].x, itemArray[arr[index]].y, picWidth, picHeight);
        // ctx.stroke();
    }

    var findImage = function(x, y){
        console.log("find  "+x+":"+y);
        for(var i=0; i<12; i++){
            if(x>itemArray[i].x && x<itemArray[i].x+picWidth && y>itemArray[i].y && y<itemArray[i].y+picHeight){
                isDragging = true;
                nowDrag = i;
                console.log("isDragging=true");
                return;
            }
        }
        isDragging = false;
        console.log("isDragging=false");
    }
       
    var rect = canvas.getBoundingClientRect();
    var scaleSizeX = canvas.width / (rect.right - rect.left);
    var scaleSizeY = canvas.height / (rect.bottom - rect.top);

    addEventListener("resize", function(){
        rect = canvas.getBoundingClientRect();
        scaleSizeX = canvas.width / (rect.right - rect.left);
        scaleSizeY = canvas.height / (rect.bottom - rect.top);
    });

    canvas.addEventListener('touchstart', function(e) {
        console.log("touches");
        canMouseX = parseInt((e.touches[0].pageX - rect.left) * scaleSizeX);  
        canMouseY = parseInt((e.touches[0].pageY - rect.top)  * scaleSizeY);
        /*var img = new Image();       //new img element,並設定來源
        img.src = "images/1.png";         
        
        img.addEventListener("load", function() {
            ctx.drawImage(img, canMouseX, canMouseY , picWidth, picHeight);
            ctx.rect(canMouseX, canMouseY , picWidth, picHeight);
            ctx.stroke();
        }, false); */   
        findImage(canMouseX, canMouseY);
    })
    canvas.addEventListener('touchend', function(e) {
        console.log("touchend");
        
        isDragging = false;
    })
    canvas.addEventListener('touchleave', function(e) {
        alert("leave");
        canMouseX = parseInt((e.touches[0].pageX - rect.left) * scaleSizeX);  
        canMouseY = parseInt((e.touches[0].pageY - rect.top)  * scaleSizeY);
        // user has left the canvas, so clear the drag flag
        isDragging = false;
    })
    canvas.addEventListener('touchmove', function(e) {
        console.log("moving");
        canMouseX = parseInt((e.touches[0].pageX - rect.left) * scaleSizeX);  
        canMouseY = parseInt((e.touches[0].pageY - rect.top)  * scaleSizeY);

        // if the drag flag is set, clear the canvas and draw the image
        if(isDragging){

            ctx.clearRect(itemArray[nowDrag].x, itemArray[nowDrag].y, picWidth, picHeight);
            ctx.drawImage(itemArray[nowDrag].img, canMouseX - picWidth/2, canMouseY - picHeight/2, picWidth, picHeight);
            //ctx.rect(canMouseX-picWidth/2, canMouseY-picHeight/2, picWidth, picHeight);
            //ctx.stroke();
            itemArray[nowDrag].x = canMouseX - picWidth/2;
            itemArray[nowDrag].y = canMouseY - picHeight/2;

            for(var i=0; i<12; i++){
                //if(i != nowDrag)
                    ctx.drawImage(itemArray[i].img, itemArray[i].x, itemArray[i].y, picWidth, picHeight);
            }
            ctx.drawImage(itemArray[nowDrag].img, itemArray[nowDrag].x, itemArray[nowDrag].y, picWidth, picHeight);
        }
        })
    
    /*//滑鼠事件
    canvas.onmousedown = function(e){
        console.log("touches");
        canMouseX = parseInt((e.clientX - rect.left) * scaleSizeX);  
        canMouseY = parseInt((e.clientY - rect.top)  * scaleSizeY);

        var img = new Image();       //new img element,並設定來源
        img.src = "images/1.png";         
        
        img.addEventListener("load", function() {
            ctx.drawImage(img, canMouseX, canMouseY , picWidth, picHeight);
            ctx.rect(canMouseX, canMouseY , picWidth, picHeight);
            ctx.stroke();
        }, false); 

        // set the drag flag
        console.log("down");
        findImage(canMouseX, canMouseY);
    }

    canvas.onmouseup = function(e){
      canMouseX=parseInt((e.clientX - rect.left) * scaleSizeX);  
      canMouseY=parseInt((e.clientY - rect.top)  * scaleSizeY);
      // clear the drag flag
      isDragging=false;
    }

    canvas.onmouseout = function(e){
      canMouseX=parseInt((e.clientX - rect.left) * scaleSizeX);  
      canMouseY=parseInt((e.clientY - rect.top)  * scaleSizeY);
      // user has left the canvas, so clear the drag flag
      isDragging=false;
    }

    canvas.ontouchmove = function(e){
      console.log("moving");
      canMouseX=parseInt((e.clientX - rect.left) * scaleSizeX);  
      canMouseY=parseInt((e.clientY - rect.top)  * scaleSizeY);

      // if the drag flag is set, clear the canvas and draw the image
      if(isDragging){
        
        ctx.clearRect(itemArray[nowDrag].x, itemArray[nowDrag].y, picWidth, picHeight);
        ctx.drawImage(itemArray[nowDrag].img, canMouseX-picWidth/2, canMouseY-picHeight/2, picWidth, picHeight);
        //ctx.rect(canMouseX-picWidth/2, canMouseY-picHeight/2, picWidth, picHeight);
        //ctx.stroke();
        itemArray[nowDrag].x = canMouseX-picWidth/2;
        itemArray[nowDrag].y = canMouseY-picHeight/2;
      }
    }*/

    var countdownfunc = function(){ 
        showTimer.innerHTML = countdownnumber;
        if(!(countdownnumber % 10)){
            handleImage(12 - countdownnumber/10 - 1);
        }
        if (countdownnumber == 0){
            clearInterval(countdownid);
            countdownid = window.setInterval(randomMove, 10);
        }
        countdownnumber--;
    }

    var nowMove = 0;
    var randomMove = function(){
        if(!isDragging){
            //ctx.clearRect(itemArray[nowMove].x, itemArray[nowMove].y, picWidth, picHeight);
            moveOneStep(nowMove);
            //handleImage(nowMove, 'randomMove');
            if(nowMove == 11)
                nowMove = 0;
            else
                nowMove++;
        }
    }  

    var moveOneStep = function(nowMove){
        ctx.clearRect(itemArray[nowMove].x, itemArray[nowMove].y, picWidth, picHeight);
        var isOk = false;
        while(!isOk){
            var xNext = (Math.random() - 0.5) > 0 ? 20 : -20; 
            var yNext = (Math.random() - 0.5) > 0 ? 20 : -20;   
            if((itemArray[nowMove].x+xNext)>0 && (itemArray[nowMove].x+xNext)<canvas.width-picWidth && (itemArray[nowMove].y+yNext)>0 && (itemArray[nowMove].y+yNext)<canvas.height-picHeight)
                isOk = true;
        }
        ctx.drawImage(itemArray[nowMove].img, itemArray[nowMove].x + xNext, itemArray[nowMove].y + yNext, picWidth, picHeight);
        itemArray[nowMove].x = itemArray[nowMove].x + xNext;
        itemArray[nowMove].y = itemArray[nowMove].y + yNext;

    }

    //想法：先全部load完(不算太大的img)比倒數時慢慢load又碰上網路不穩斷線好
    for(var i=0; i<12; i++)   loadImage(i);

    function init(){

        arr.sort(function() { return Math.random() - 0.5 });
        //i = 0;
        showTimer = document.getElementById("timer");
        showTimer.innerHTML = countdownnumber;
        countdownnumber--;
        countdownid = window.setInterval(countdownfunc,100);
    }


        //http://jeffdeng.me/js/2015/07/06/canvas-resolution/
        //canvas.width/height 表示的是设备像素，而 canvas.style.width/height 表示的是CSS像素

</script>
